package ru.itmo.wp.model.repository.impl;

import com.google.common.reflect.TypeToken;
import ru.itmo.wp.model.database.DatabaseUtils;
import ru.itmo.wp.model.domain.Entity;
import ru.itmo.wp.model.exception.RepositoryException;

import javax.sql.DataSource;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;

@SuppressWarnings("SqlResolve")
public abstract class BasicRepositoryImpl<T extends Entity> {
    private final DataSource DATA_SOURCE = DatabaseUtils.getDataSource();

    @SuppressWarnings("UnstableApiUsage")
    private final String entityName = new TypeToken<T>(getClass()) {}.getRawType().getSimpleName();

    public T find(long id) {
        return findBy("id", id);
    }

    public List<T> findAll() {
        return findAllWhere("");
    }

    protected T findBy(String columnName, Object columnValue) {
        return findBy(Collections.singletonMap(columnName, columnValue));
    }

    protected T findBy(Map<String, Object> columns) {
        String whereClause = getWhereClause(columns.keySet());
        return findWhere(whereClause, columns.values().toArray());
    }

    protected T findWhere(String whereClause, Object... values) {
        try (Connection connection = getConnection()) {
            try (PreparedStatement statement = connection.prepareStatement(
                    "SELECT * FROM " + entityName +
                        " WHERE " + (whereClause.isEmpty() ? "TRUE" : whereClause))) {
                setObjects(statement, values);
                try (ResultSet resultSet = statement.executeQuery()) {
                    return toEntity(statement.getMetaData(), resultSet);
                }
            }
        } catch (SQLException e) {
            throw new RepositoryException(String.format("Can't find %s.", entityName), e);
        }
    }

    protected List<T> findAllBy(String columnName, Object columnValue) {
        return findAllBy(Collections.singletonMap(columnName, columnValue));
    }

    protected List<T> findAllBy(Map<String, Object> columns) {
        String whereClause = getWhereClause(columns.keySet());
        return findAllWhere(whereClause, columns.values().toArray());
    }

    protected List<T> findAllWhere(String whereClause, Object... values) {
        List<T> entities = new ArrayList<>();
        try (Connection connection = getConnection()) {
            try (PreparedStatement statement = connection.prepareStatement(
                    "SELECT * FROM " + entityName +
                        " WHERE " + (whereClause.isEmpty() ? "TRUE" : whereClause) +
                        " ORDER BY id DESC")) {
                setObjects(statement, values);

                try (ResultSet resultSet = statement.executeQuery()) {
                    T entity;
                    while ((entity = toEntity(statement.getMetaData(), resultSet)) != null) {
                        entities.add(entity);
                    }
                }
            }
        } catch (SQLException e) {
            throw new RepositoryException(String.format("Can't find %s.", entityName), e);
        }
        return entities;
    }

    protected void save(T entity, Map<String, Object> columns) {
        try (Connection connection = DATA_SOURCE.getConnection()) {
            String stringStatement =
                    "INSERT INTO " + entityName +
                        " (" + String.join(", ", columns.keySet()) + ", creationTime) " +
                    "VALUES (" + String.join(", ", getPlaceholders(columns.size())) + ", NOW())";

            try (PreparedStatement statement = connection.prepareStatement(
                    stringStatement, Statement.RETURN_GENERATED_KEYS)) {
                setObjects(statement, columns.values().toArray());

                if (statement.executeUpdate() != 1) {
                    throw new RepositoryException(String.format("Can't save %s.", entityName));
                } else {
                    ResultSet generatedKeys = statement.getGeneratedKeys();
                    if (generatedKeys.next()) {
                        entity.setId(generatedKeys.getLong(1));
                        entity.setCreationTime(find(entity.getId()).getCreationTime());
                    } else {
                        throw new RepositoryException(
                                String.format("Can't save %s [no autogenerated fields].", entityName));
                    }
                }
            }
        } catch (SQLException e) {
            throw new RepositoryException(String.format("Can't save %s.", entityName), e);
        }
    }

    protected void update(T entity, Map<String, Object> columns) {
        try (Connection connection = getConnection()) {
            try (PreparedStatement statement = connection.prepareStatement(
                    "UPDATE " + entityName +
                        " SET " + columns.keySet().stream()
                            .map(column -> column + "=?")
                            .collect(Collectors.joining(", ")) +
                        " WHERE id=?")) {
                setObjects(statement, columns.values().toArray());
                statement.setLong(columns.size() + 1, entity.getId());
                if (statement.executeUpdate() != 1) {
                    throw new RepositoryException(String.format("Can't update %s.", entityName));
                }
            }
        } catch (SQLException e) {
            throw new RepositoryException(String.format("Can't update %s.", entityName), e);
        }
    }

    protected abstract T toEntity(ResultSetMetaData metaData, ResultSet resultSet) throws SQLException;

    private void setObjects(PreparedStatement statement, Object... values) throws SQLException {
        int index = 1;
        for (Object value : values) {
            statement.setObject(index++, value);
        }
    }

    protected Connection getConnection() throws SQLException {
        return DATA_SOURCE.getConnection();
    }

    private List<String> getPlaceholders(int size) {
        return Collections.nCopies(size, "?");
    }

    private String getWhereClause(Collection<String> columnNames) {
        return columnNames.stream()
                .map(column -> column + "=?")
                .collect(Collectors.joining(" AND "));
    }
}
